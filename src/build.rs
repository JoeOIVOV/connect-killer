extern crate capnpc;

use std::fs::{File, create_dir_all};
use std::io::{self, Write, BufRead, BufReader};
use std::path::Path;

fn main() -> io::Result<()> {
    println!("cargo:rerun-if-changed=openpilot/cereal");
    let src_prefix = "openpilot/cereal";
    let capnp_files = ["log.capnp", "car.capnp", "custom.capnp", "legacy.capnp"];
    let out_dir = Path::new("src/cereal");

    // Ensure the openpilot/cereal directory exists
    if !Path::new(src_prefix).exists() {
        eprintln!("Error: Directory not found: {}", src_prefix);
        return Err(io::Error::new(io::ErrorKind::NotFound, format!("Directory not found: {}", src_prefix)));
    }

    // Ensure the output directory exists
    create_dir_all(&out_dir)?;

    // Create CompilerCommand using a loop to add all files
    let mut command = capnpc::CompilerCommand::new();
    command.src_prefix(&src_prefix).output_path(&out_dir);
    for file in &capnp_files {
        let file_path = format!("{}/{}", &src_prefix, file);
        if !Path::new(&file_path).exists() {
            eprintln!("Error: File not found: {}", file_path);
            return Err(io::Error::new(io::ErrorKind::NotFound, format!("File not found: {}", file_path)));
        }
        command.file(file_path);
    }
    command.default_parent_module(vec!["cereal".into()]);
    command.run().unwrap();

    // Create or truncate the mod.rs file
    let mod_rs_path = out_dir.join("mod.rs");
    let mut mod_rs_file = File::create(&mod_rs_path)?;

    // Write the generated file notice
    writeln!(mod_rs_file, "// This file is generated by build.rs")?;
    for file in &capnp_files {
        let module_name = file.strip_suffix(".capnp").unwrap_or(file);
        writeln!(mod_rs_file, "pub mod {}_capnp;", module_name)?;
    }

    // --- BEGIN: Generate get_event_type_name match arms from log.capnp ---
    let log_capnp_path = Path::new("openpilot/cereal/log.capnp");
    let generated_path = Path::new("src/cereal/generated_event_type_names.rs");
    let log_file = File::open(log_capnp_path)?;
    let reader = BufReader::new(log_file);
    let mut in_event_struct = false;
    let mut in_union = false;
    let mut match_arms = Vec::new();
    for line in reader.lines() {
        let line = line?;
        let trimmed = line.trim();
        if trimmed.starts_with("struct Event") {
            in_event_struct = true;
        }
        if in_event_struct && trimmed.starts_with("union {") {
            in_union = true;
            continue;
        }
        if in_union && trimmed.starts_with("}") {
            break;
        }
        if in_union {
            // Try to match lines like: "initData @1 :InitData;"
            if let Some((field, _)) = trimmed.split_once("@") {
                let field = field.trim();
                if !field.is_empty() && !field.starts_with("#") && !field.starts_with("//") {
                    // Remove trailing ":..." if present
                    let field_name = field.split_whitespace().next().unwrap_or("");
                    if !field_name.is_empty() {
                        // Capitalize first letter and append _ if needed
                        let mut enum_variant = field_name.to_string();
                        // Capnp convention: fields like fooBar -> FooBar
                        if let Some(first) = enum_variant.get_mut(0..1) {
                            first.make_ascii_uppercase();
                        }
                        // Handle DEPRECATED fields (keep as is)
                        let variant = if enum_variant.ends_with("DEPRECATED") {
                            enum_variant.clone()
                        } else {
                            enum_variant.clone()
                        };
                        // Output: LogEvent::Which::Variant(_) => "fieldName".to_string(),
                        match_arms.push(format!(
                            "        LogEvent::Which::{}(_) => \"{}\".to_string(),",
                            variant,
                            field_name
                        ));
                    }
                }
            }
        }
    }
    // Write to generated file
    let mut gen_file = File::create(generated_path)?;
    writeln!(gen_file, "// This file is @generated by build.rs. Do not edit manually.\n")?;
    writeln!(gen_file, "use crate::cereal::log_capnp::event as LogEvent;")?;
    writeln!(gen_file, "pub fn generated_event_type_name(event_type: &LogEvent::WhichReader) -> String {{")?;
    writeln!(gen_file, "    match event_type {{")?;
    for arm in match_arms {
        writeln!(gen_file, "{}", arm)?;
    }
    writeln!(gen_file, "    }}")?;
    writeln!(gen_file, "}}")?;
    // --- END: Generate get_event_type_name match arms ---

    Ok(())
}